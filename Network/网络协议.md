## TCP

### TCP基本介绍
TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的传输层协议。它提供了端到端的通信服务，确保数据包按顺序到达，并且没有丢失或重复。TCP通过三次握手建立连接，并使用确认机制和重传机制来保证数据的可靠传输。

### TCP头部结构
TCP头部包含多个字段，用于控制和管理数据传输。主要字段包括：
- 源端口（Source Port）：16位，表示发送端的端口号。
- 目的端口（Destination Port）：16位，表示接收端的端口号。
- 序列号（Sequence Number）：32位，表示数据包的序列号
- 确认号（Acknowledgment Number）：32位，表示期望收到的下一个字节的序列号。
- 数据偏移（Data Offset）：4位，表示TCP头部的长度。
- 保留（Reserved）：6位，保留供将来使用，通常设置为0。
- 控制位（Flags）：6位，包括URG、ACK、PSH、RST、SYN、FIN等标志位，用于控制连接状态和数据传输。
- 窗口大小（Window Size）：16位，表示接收方的缓冲区大小。
- 校验和（Checksum）：16位，用于错误检测。

### TCP三次握手过程
1. 第一次握手：客户端发送一个SYN（同步）包到服务器，表示请求建立连接，并进入SYN_SEND状态。
2. 第二次握手：服务器收到SYN包后，回复一个SYN-ACK（同步-确认）包，表示同意建立连接，并进入SYN_RECV状态。
3. 第三次握手：客户端收到SYN-ACK包后，发送一个ACK（确认）包给服务器，表示连接建立成功，双方进入ESTABLISHED状态。

### 为什么需要三次握手
三次握手的目的是为了确保双方都准备好进行数据传输，并且同步初始序列号。通过三次握手，客户端和服务器可以确认彼此的接收能力和发送能力，从而避免数据丢失和混乱。

具体来说：
- 第一次握手，服务器知道客户端有能力发送数据，自己有能力接收数据。
- 第二次握手，客户端知道服务器有能力发送&接收数据，自己有能力发送&接收数据。
- 第三次握手，服务端知道客户端有能力发送&接收数据，自己有能力发送&接收数据。

### TCP四次挥手过程
1. 第一次挥手：客户端发送一个FIN（结束）包到服务器，表示数据发送完毕，进入FIN_WAIT_1状态。
2. 第二次挥手：服务器收到FIN包后，回复一个ACK包，表示确认收到FIN包，进入CLOSE_WAIT状态。客户端收到ACK包后，进入FIN_WAIT_2状态。
3. 第三次挥手：服务器准备关闭连接时，发送一个FIN包给客户端，进入LAST_ACK状态。
4. 第四次挥手：客户端收到FIN包后，回复一个ACK包，表示确认收到FIN包，进入TIME_WAIT状态。服务器收到ACK包后，关闭连接。

### 为什么需要四次挥手
四次挥手的目的是为了确保双方都能正常关闭连接，避免数据丢失。由于TCP是全双工通信，客户端和服务器可以独立地关闭各自的发送和接收通道。因此，需要四次挥手来确保双方都能正确地关闭连接。

具体来说：
- 第一次挥手，客户端告诉服务器自己已经没有数据发送了，请求关闭发送通道。
- 第二次挥手，服务器通知客户端，自己已经收到关闭请求，但你还不能断开连接，因为服务器可能还有数据要发送给你。
- 第三次挥手，服务器告诉客户端自己也没有数据发送了，请求关闭发送通道。
- 第四次挥手，客户端确认收到服务器的关闭请求，双方连接正式关闭。

#### tip: 全双工，半双工和单工
- 全双工（Full-Duplex）：通信双方可以同时进行发送和接收操作。例如，电话通话就是全双工通信。
- 半双工（Half-Duplex）：通信双方可以进行发送和接收操作，但不能同时进行。例如，对讲机就是半双工通信。
- 单工（Simplex）：通信只能单向进行，只有一方可以发送数据，另一方只能接收数据。例如，电视广播就是单工通信。

### DOS攻击中的SYN洪水攻击
SYN洪水攻击是一种常见的拒绝服务（DoS）攻击，攻击者通过发送大量的SYN请求包来耗尽服务器的资源，导致合法用户无法建立连接。攻击过程如下：
1. 攻击者向目标服务器发送大量的SYN请求包，伪装成不同的源IP地址。
2. 服务器收到SYN请求后，分配资源并发送SYN-ACK包，等待客户端的ACK确认。
3. 由于攻击者并不发送ACK包，服务器的连接表被大量未完成的连接占满，无法处理新的合法连接请求，导致服务瘫痪。

### 粘包与拆包
粘包和拆包是TCP协议中常见的问题，主要由于TCP是面向字节流的协议，没有明确的消息边界。
- 粘包（Packet Coalescing）：当发送方连续发送多个小数据包时，底层TCP可能会将这些数据包合并成一个大包进行发送，导致接收方无法区分原始的消息边界。
- 拆包（Packet Fragmentation）：当发送方发送一个大数据包时，底层TCP可能会将其拆分成多个小包进行发送，导致接收方需要重新组装这些小包才能还原原始消息。

由于TCP面向字节流的设计，导致粘包和拆包在TCP通信中是不可避免的。应用层需要通过特定的协议设计来解决这些问题，例如在每个消息前添加固定长度的头部信息，指明消息的长度，从而实现正确的消息边界识别。

通俗来说，可以认为TCP是一辆货车，发送方每次调用send（）就是往车上装货，而TCP只在意车上有多少货（字节流），从而决定是否发车，而并不关心每次装的是什么货（消息边界），以及装了几次货。

### 头阻塞（Head-of-Line Blocking）
头阻塞是指在TCP协议中，由于数据包按顺序传输的特性，导致后续的数据包必须等待前面的数据包被处理完毕后才能继续处理的现象。这种现象会影响网络性能，增加延迟。

虽然当package 1丢失时，后续的package 2、3、4等都可以到达接收端，但由于TCP要求按顺序交付数据，接收端必须等待package 1的重传并正确接收后，才能处理package 2、3、4等。这就导致了头阻塞现象。

## SCTP

### SCTP基本介绍
SCTP（Stream Control Transmission Protocol，流控制传输协议）是一种传输层协议，设计用于在IP网络上传输消息。它结合了TCP的可靠性和UDP的多路复用特性，支持多条独立的流（streams）在同一连接中传输数据。SCTP最初用于电信信令传输，但现在也被用于其他应用场景。

### SCTP的多宿主特性
SCTP支持多宿主（multi-homing）特性，允许一个SCTP端点绑定多个IP地址。这意味着如果一个网络路径出现故障，SCTP可以自动切换到另一个可用的路径，从而提高连接的可靠性和容错能力。

例如： 主机A（IP1, IP2） <====> 主机B（IP3, IP4）

其中 主机A有两个IP地址（IP1和IP2），主机B也有两个IP地址（IP3和IP4）。这就构成了多个路径：
- 路径1：IP1 <====> IP3
- 路径2：IP1 <====> IP4
- 路径3：IP2 <====> IP3
- 路径4：IP2 <====> IP4
如果路径1出现故障，SCTP可以自动切换到路径2、路径3或路径4，确保数据传输的连续性。

默认情况下，SCTP会选择一个主路径进行数据传输，并定期发送心跳包（Heartbeat）来监测其他路径的可用性。一旦检测到主路径不可用，SCTP会切换到备用路径继续传输数据，但不会同时使用多个路径进行数据传输。

### SCTP的多流特性
SCTP支持多流（multi-streaming）特性，允许在同一SCTP连接中创建多个独立的流（streams）。每个流可以独立传输消息，避免了TCP中的头阻塞问题。

这里的流不是上述的路径，每个路径中可以包含多个流。流是逻辑上的概念，通过流标识符（Stream Identifier）来区分不同的流。应用程序可以根据需要创建多个流，并在每个流中独立发送和接收消息。

### SCTP的消息传输
SCTP以消息为单位进行数据传输，每个消息可以独立发送和接收，这避免了TCP中的粘包和拆包问题。SCTP在传输消息时，保留了消息的边界信息，接收端可以准确地还原原始消息。

此外，SCTP支持部分可靠传输（Partial Reliability），允许应用程序指定流(Stream)中某些消息可以不可靠传输，从而提高传输效率。其中不可靠传输的消息可能会丢失，可能会乱序到达，但不会影响其他流的传输。

### SCTP的四次握手过程
SCTP的连接建立过程采用四次握手（Four-Way Handshake），具体步骤如下：
1. 第一次握手：客户端发送一个INIT包到服务器，表示请求建立连接。
2. 第二次握手：服务器收到INIT包后，回复一个INIT-ACK包，表示同意建立连接。
3. 第三次握手：客户端收到INIT-ACK包后，发送一个COOKIE-ECHO包给服务器，表示确认连接请求。
4. 第四次握手：服务器收到COOKIE-ECHO包后，回复一个COOKIE-ACK包，表示连接建立成功。

四次握手可以避免SYN洪水攻击，因为服务器在收到INIT包后不会立即分配资源，而是等待客户端发送COOKIE-ECHO包进行确认，从而减少了资源浪费的风险。